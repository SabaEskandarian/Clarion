package main

import (
    "log"
    "crypto/tls"
    //"net"
    //"os"
    //"time"
    //"unsafe"
    //"io"
    //"crypto/rand"
    "golang.org/x/crypto/nacl/box"
    //"sync/atomic"
    "strings"
    "strconv"
    
    "shufflemessage/mycrypto" //my crypto in crypto.go, the rest generated by Goff https://github.com/ConsenSys/goff

)

func server(numServers, msgBlocks, batchSize, myNum int, leaderAddr string) {
    
    
    //using a deterministic source of randomness for testing 
    //this is just for testing so the different parties share a key
    //in reality the public keys of the servers/auditors should be known 
    //ahead of time and those would be used
    pubKeys := make([]*[32]byte, numServers)
    
    var err error
    var mySecKey *[32]byte
    
    for i := 0; i < numServers; i++ {
        
        if i == myNum {
            pubKeys[i], mySecKey, err = box.GenerateKey(strings.NewReader(strings.Repeat(strconv.Itoa(i),10000)))
            if err != nil {
                log.Println(err)
                return
            }
        } else {
            pubKeys[i], _, err = box.GenerateKey(strings.NewReader(strings.Repeat(strconv.Itoa(i),10000)))
            if err != nil {
                log.Println(err)
                return
            }
        }

    }
    
    //temp so it will compile; TODO remove this when we use mySecKey
    log.Println(mySecKey)
 
    conf := &tls.Config{
         InsecureSkipVerify: true,
    }
    
    //connect to server
    conn, err := tls.Dial("tcp", leaderAddr, conf)
    if err != nil {
        log.Println(err)
        return 
    }
    defer conn.Close()
    
    //some relevant values
    //48 is for mac key share, mac, encryption key, 16 bytes each
    shareLength := 48 + 16*msgBlocks
    boxedShareLength := (shareLength + box.AnonymousOverhead)
    //server share is longer because there needs to be space for a share of _each_ mac key share
    serverShareLength := 16*msgBlocks + 32 + numServers * 16
    
    //data structure for holding batch of messages
    //each entry will be of length serverShareLength
    db := make([][]byte, batchSize)
    for i:= 0; i < batchSize; i++ {
        db[i] = make([]byte, serverShareLength)
    }

    //main server loop below
    for {
        //client connection receiving phase
        for msgCount := 0; msgCount < batchSize; msgCount++ {
            
            //read permuted index from leader
            prelimPermIndex := byteToInt(readFromConn(conn, 4))
            
            //read client box from leader, unbox
            clientBox := readFromConn(conn, boxedShareLength)
            
            clientMessage, ok := box.OpenAnonymous(nil, clientBox, pubKeys[myNum], mySecKey)
            if !ok {
                panic("decryption not ok!!")
            }
            
            //expand seeds, store in db
            copy(db[prelimPermIndex][0:16*numServers], 
                mycrypto.ExpandKeyShares(myNum, numServers, clientMessage[0:16]))
            copy(db[prelimPermIndex][16*numServers:], clientMessage[16:shareLength])

        }
        
        //processing phase

        //TODO
        
    }
}
