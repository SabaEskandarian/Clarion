package main

import (
    "log"
    "crypto/tls"
    "net"
    //"os"
    "time"
    //"unsafe"
    //"io"
    //"crypto/rand"
    "golang.org/x/crypto/nacl/box"
    //"sync/atomic"
    //"strconv"
    
    "shufflemessage/mycrypto" //my crypto in crypto.go, the rest generated by Goff https://github.com/ConsenSys/goff
)

func leader(numServers, msgBlocks, batchSize int) {
    
    log.Println("This server is the leader")
    
    //setup
    cer, err := tls.LoadX509KeyPair("server.crt", "server.key")
    if err != nil {
        log.Println(err)
        return
    }
    config := &tls.Config{Certificates: []tls.Certificate{cer}}
    port := ":4443"
    ln, err := tls.Listen("tcp", port, config)  
    if err != nil {
        log.Println(err)
        return
    }
    defer ln.Close()
    
    //first connection from Aux server
    auxConn, err := ln.Accept()
    if err != nil {
        log.Println(err)
        return
    }
    auxConn.SetDeadline(time.Time{})
        
    //holds connections to the other shuffle servers
    conns := make([]net.Conn, (numServers-1))

    for i := 0; i < numServers - 1; i++ {
        conns[i], err = ln.Accept()
        if err != nil {
            log.Println(err)
            return
        }
        conns[i].SetDeadline(time.Time{})
    }
        
    //some relevant values
    //48 is for mac key share, mac, encryption key, 16 bytes each
    shareLength := 48 + 16*msgBlocks
    boxedShareLength := (shareLength + box.AnonymousOverhead)
    clientTransmissionLength := (numServers - 1) * boxedShareLength + shareLength
    //server share is longer because there needs to be space for a share of _each_ mac key share
    serverShareLength := 16*msgBlocks + 32 + numServers * 16
    
    //data structure for holding batch of messages
    //each entry will be of length serverShareLength
    db := make([][]byte, batchSize)
    for i:= 0; i < batchSize; i++ {
        db[i] = make([]byte, serverShareLength)
    }

    //set up running average for timing TODO uncomment when used
    //batchesCompleted := 0
    //var totalTime time.Duration
    
    //main server behavior below
    for {
        //client connection receiving phase
        //NOTE: this phase of server is currently single-threaded. 
        //Throughput could be significantly increased by making the servers handle multiple client requests concurrently
        
        //generate preliminary permutation
        prelimPerm := mycrypto.GenPerm(batchSize)
        
        //NOTE: the preliminary permutation is effectively "for free" to evaluate because the server just copies the client messages into their permuted indices directly
        
        //for performance measurement we'll only implement the case where all client messages are good
        //we'll just panic later if a blind mac verification fails
        for msgCount := 0; msgCount < batchSize; msgCount++ {
            //handle connections from client, pass on boxes
            
            //client connection
            clientConn, err := ln.Accept()
            if err != nil {
                log.Println(err)
                return
            }
            clientConn.SetDeadline(time.Time{})
            clientTransmission := readFromConn(clientConn, clientTransmissionLength)
            clientConn.Close()
            
            //NOTE: the next steps of handling messages sent to this server and forwarding messages to other servers could definitely be done in parallel too
            
            //handle the message sent for this server
            copy(db[prelimPerm[msgCount]][0:16*numServers], 
                mycrypto.ExpandKeyShares(0, numServers, clientTransmission[0:16]))
            copy(db[prelimPerm[msgCount]][16*numServers:], clientTransmission[16:shareLength])
            
            //pass on the boxes to the other servers, send the index they should be placed in too
            for i := 0; i < numServers-1; i++ {
                
                //send prelimPerm[msgCount]
                writeToConn(conns[i], intToByte(prelimPerm[msgCount]))
                
                //send client message
                start := shareLength + i*boxedShareLength
                end := shareLength + (i+1)*boxedShareLength
                writeToConn(conns[i], clientTransmission[start:end])
            }
        }
        
        //processing phase
        //NOTE: in reality, the blind verification and aux server stuff could be done as messages arrive
        //this would speed up the processing time, esp. if the server were multithreaded
        //but I'm handling everything for a batch at once so I can report performance for processing a batch
        
        //TODO: ping aux server, get beaver triples and translations from aux server, pass on boxes     
        
        //TODO: if numServers > 2, timing starts here. If numServers == 2, timing starts with processing phase
        
        //TODO: blind MAC verification, 
        
        //TODO: shuffle
        
        //TODO commit, reveal, mac verify, decrypt
    }
}
