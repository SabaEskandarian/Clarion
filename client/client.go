package main

import (
    "log"
    "crypto/tls"
    //"unsafe"
    "time"
    "crypto/rand"
    "golang.org/x/crypto/nacl/box"
    "strings"
    "os"
    "strconv"
    
    "shufflemessage/mycrypto" //my crypto in crypto.go, the rest generated by Goff https://github.com/ConsenSys/goff
)

var leadServer string

func main() {

	leadServer = "127.0.0.1:4443"
	
	msgBlocks := 2
	numServers := 2
	numMsgs := 1000
    numThreads := 1

    if len(os.Args) < 6 {
        log.Println("usage: client [leadServerIp:port] [numServers] [message length in blocks] [numMsgs] [numThreads]")
        log.Println("set numServers to 2 for the 1 of 3 scheme. message length and numServers must match the servers")
        return
    } else {
        leadServer = os.Args[1]
        numServers, _ = strconv.Atoi(os.Args[2])
        msgBlocks, _ = strconv.Atoi(os.Args[3])
        numMsgs, _ = strconv.Atoi(os.Args[4])
        numThreads, _ = strconv.Atoi(os.Args[5])
    }
    
    log.SetFlags(log.Lshortfile)
    
    if numServers < 2 {
    	log.Println("numServers must be at least 2")
    	return
    }
    
    //using a deterministic source of randomness for testing 
    //this is just for testing so the different parties share a key
    //in reality the public keys of the servers/auditors should be known 
    //ahead of time and those would be used
    pubKeys := make([]*[32]byte, numServers)
    
    var err error;
    
    for i := 0; i < numServers; i++ {
    	pubKeys[i], _, err = box.GenerateKey(strings.NewReader(strings.Repeat(strconv.Itoa(i),10000)))
    	if err != nil {
        	log.Println(err)
        	return
    	}
    }
    
    blocker := make(chan int)
    
    for i:=0; i < numThreads; i++ {
        
        //function to make a client connection and time the whole thing (per thread)
        go func(server string, threadNum, numMsgs, msgBlocks int, pubKeys []*[32]byte) {
            
            var totalTime time.Duration
            
            for i := 0; i < numMsgs; i++ {
                
                msgType :=0
                if i < 26 {
                    msgType += i
                }
            
                elapsedTime := clientConnection(server, msgType, msgBlocks, pubKeys);

                totalTime += elapsedTime
            }
            
            //This benchmarks only the crypto stuff, not the network parts
            log.Printf("Thread %d average write computation time (msg blocks: %d, num Msgs: %d): %s\n", threadNum, msgBlocks, numMsgs, totalTime/time.Duration(numMsgs))
            
            blocker <- 1
            return
            
        }(leadServer, i, numMsgs, msgBlocks, pubKeys)
        
    }
    
    for i:=0; i < numThreads; i++ {
        <- blocker
    }
}


func clientConnection(server string, msgType, msgBlocks int, pubKeys []*[32]byte) time.Duration {
    
     conf := &tls.Config{
         InsecureSkipVerify: true,
    }
    
    //connect to server
    conn, err := tls.Dial("tcp", server, conf)
    if err != nil {
        log.Println(err)
        return 0
    }
    defer conn.Close()
    
    startTime := time.Now()
    
    numServers := len(pubKeys)
        
    //generate the MACed ciphertext, MAC, and all the keys; secret share
    //look in vendors/mycrypto/crypto.go for details
    keyAndCt := mycrypto.MakeCT(msgBlocks, msgType)
    mac, keyShareSeeds := mycrypto.WeirdMac(numServers, keyAndCt)
    bodyShares := mycrypto.Share(numServers, append(mac, keyAndCt...))
        
    //box shares with the appropriate key share seeds prepended
    //"box" sent to leader is actually just sent to the leader without a box
    msgToSend := append(keyShareSeeds[0],bodyShares[0]...)
    
    //log.Printf("Msg length for one share: %d\n", len(msgToSend))
    //log.Printf("encryption size overhead: %d\n", box.AnonymousOverhead)
    
    for i:= 1; i < numServers; i++ {
        
        //SealAnonymous appends its output to msgToSend
        boxedMessage, err := box.SealAnonymous(nil, append(keyShareSeeds[i],bodyShares[i]...), pubKeys[i], rand.Reader)
        if err != nil {
            log.Println(err)
            return 0
        }
        msgToSend = append(msgToSend, boxedMessage...)
    }
    
    
    elapsedTime := time.Since(startTime)
    
    //send everything to server
    n, err := conn.Write(msgToSend)
    if err != nil {
        log.Println(n, err)
        return 0
    }
    
    return elapsedTime
}
